name: Snyk Static Check
description: A reusable composite action to run Snyk IaC or Code dependency scans

inputs:
  snyk-org:
    description: The Snyk organization
    required: true

  snyk-endpoint:
    description: The custom Snyk API endpoint (optional if using default)
    required: false
    default: ""

  snyk-token:
    description: The Snyk API token
    required: true

  severity-threshold:
    description: Minimum severity threshold to report (low, medium, high, critical)
    required: false
    default: "low"

  scan-mode:
    description: Choose which type of scan to run(iac or code)
    required: true

  code-file:
    description: The dependency file to scan (e.g., requirements.txt, poetry.lock)
    required: false
    default: "requirements.txt"

  skip-unresolved:
    description: Add the --skip-unresolved flag (true/false)
    required: false
    default: "false"

  exclude-licenses:
    description: Add the --exclude-licenses flag (true/false)
    required: false
    default: "false"

  json-output-file:
    required: false
    type: string
    description: Snyk JSON file output
    default: snyk.json

  update-pr-with-scan-results:
    required: false
    type: boolean
    description: Update PR with scan results
    default: false

  use-policy-file:
    description: Whether to use a .snyk policy file to ignore known/approved issues
    required: false
    default: "true"

  policy-file-path:
    description: Path to a custom .snyk policy file (relative to the repo root)
    required: false
    default: "."

  install-requirements:
    description: Whether to install Python requirements before scanning
    required: false
    type: boolean
    default: false

  python-package-manager:
    description: Python package manager to use for installing dependencies (pip or poetry)
    required: false
    default: "pip"
    
  generate-pdf-report:
    description: Generate a PDF report using snyk-to-html
    required: false
    type: boolean
    default: false
runs:
  using: "composite"
  steps:
    - name: Validate Inputs
      run: |
        echo "üîç Validating inputs..."

        if [[ "${{ inputs.scan-mode }}" != "iac" && "${{ inputs.scan-mode }}" != "code" ]]; then
          echo "‚ùå Invalid scan-mode '${{ inputs.scan-mode }}'. Must be 'iac' or 'code'."
          exit 1
        fi

        if [[ "${{ inputs.scan-mode }}" == "code" && -z "${{ inputs.code-file }}" ]]; then
          echo "‚ùå 'code-file' must be provided when scan-mode is 'code'."
          exit 1
        fi

        if [[ "${{ inputs.install-requirements }}" == "true" ]]; then
          if [[ "${{ inputs.python-package-manager }}" != "pip" && "${{ inputs.python-package-manager }}" != "poetry" ]]; then
            echo "‚ùå Invalid python-package-manager '${{ inputs.python-package-manager }}'. Must be 'pip' or 'poetry'."
            exit 1
          fi
        fi

        if [[ "${{ inputs.update-pr-with-scan-results }}" == "true" && -z "${{ inputs.json-output-file }}" ]]; then
          echo "‚ùå 'json-output-file' must be defined when update-pr-with-scan-results is true."
          exit 1
        fi

        echo "‚úÖ All inputs look good."
      shell: bash
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Install Snyk CLI
      run: npm install -g snyk --quiet
      shell: bash

    - name: Configure Snyk Organization and Endpoint
      run: |
        snyk config set org=${{ inputs.snyk-org }}
        if [[ -n "${{ inputs.snyk-endpoint }}" ]]; then
          snyk config set endpoint=${{ inputs.snyk-endpoint }}
        fi
      shell: bash

    - name: Authenticate Snyk
      run: |
        if [[ -z "${{ inputs.snyk-token }}" ]]; then
          echo "Error: SNYK_TOKEN is not set"
          exit 1
        fi
        snyk auth "${{ inputs.snyk-token }}"
      shell: bash

    - name: Run Snyk IaC Scan
      if: ${{ inputs.scan-mode == 'iac' }}
      run: snyk iac test --severity-threshold=${{ inputs.severity-threshold }} --report --json-file-output=${{ inputs.json-output-file }}
      shell: bash
      continue-on-error: true

    - name: Install Python requirements
      if: ${{ inputs.install-requirements == 'true' && inputs.scan-mode == 'code' }}
      shell: bash
      run: |
        python -m pip install --upgrade pip
        if [[ "${{ inputs.python-package-manager }}" == "poetry" ]]; then
          pip install poetry
          poetry install --no-root
        else
          pip install -r ${{ inputs.code-file }}
        fi

    - name: Run Snyk Code Dependency Scan
      if: ${{ inputs.scan-mode == 'code' }}
      run: |
        CMD="snyk test --file=${{ inputs.code-file }} --severity-threshold=${{ inputs.severity-threshold }}"

        if [[ "${{ inputs.skip-unresolved }}" == "true" ]]; then
          CMD="$CMD --skip-unresolved"
        fi

        if [[ "${{ inputs.exclude-licenses }}" == "true" ]]; then
          CMD="$CMD --exclude-licenses"
        fi

        if [[ "${{ inputs.use-policy-file }}" == "true" ]]; then
          CMD="$CMD --policy-path=${{ inputs.policy-file-path }}"
        fi

        CMD="$CMD --json-file-output=${{ inputs.json-output-file }}"

        echo "Running: $CMD"
        eval "$CMD"
      shell: bash
      continue-on-error: true
      
    - name: Post results to PR
      if: ${{ always() && inputs.update-pr-with-scan-results }}
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const codeMarker = '<!-- snyk-scan-comment-code -->';
          const iacMarker = '<!-- snyk-scan-comment-iac -->';
    
          const filePath = path.resolve('${{ inputs.json-output-file }}');
          if (!fs.existsSync(filePath)) {
            console.log('‚ùå Snyk output file not found:', filePath);
            return;
          }
    
          const results = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          // Detect if this is an IaC scan based on the presence of infrastructureAsCodeIssues
          const isIacScan = Array.isArray(results) && results.some(r => r.hasOwnProperty('infrastructureAsCodeIssues'));
          let body = '';
          const number = context.payload.pull_request?.number ?? context.issue?.number;
          if (!number) {
            console.log('‚ùå Not running in a pull request context');
            return;
          }
    
          const comments = await github.rest.issues.listComments({
            issue_number: number,
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          console.log(`üí¨ Found ${comments.data.length} comments on this PR.`);
    
          const marker = isIacScan ? iacMarker : codeMarker;
          const existing = comments.data.find(c => c.body.includes(marker));
    
          if (isIacScan) {
            console.log('üîç Detected IaC scan format.');
            
            // Collect all issues from all scan results
            const allIssues = [];
            
            for (const result of results) {
              if (result.ok === true && (!result.infrastructureAsCodeIssues || result.infrastructureAsCodeIssues.length === 0)) {
                continue; // Skip if no issues
              }
              
              const targetFile = result.targetFile || 'Unknown file';
              
              // Process each issue in the file
              if (result.infrastructureAsCodeIssues && result.infrastructureAsCodeIssues.length > 0) {
                for (const issue of result.infrastructureAsCodeIssues) {
                  allIssues.push({
                    file: targetFile,
                    id: issue.id || issue.publicId || 'N/A',
                    title: issue.title || (issue.iacDescription?.issue || 'Unknown issue'),
                    severity: issue.severity || 'unknown',
                    resourcePath: issue.msg || 'Unknown resource',
                    impact: issue.iacDescription?.impact || 'Not specified',
                    resolution: issue.iacDescription?.resolve || 'Not specified',
                    documentation: issue.documentation || 
                                  (issue.references && issue.references.length > 0 ? issue.references[0] : 'N/A')
                  });
                }
              }
            }
            
            if (allIssues.length === 0) {
              console.log('‚úÖ No actionable issues in IaC scan.');
              if (existing) {
                console.log('üßπ Deleting outdated IaC scan comment.');
                await github.rest.issues.deleteComment({
                  comment_id: existing.id,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
              }
              return;
            }
    
            // Create detailed markdown table for IAC issues
            let table = '| File | Resource | Severity | Issue | Impact | Resolution | Link |\n|------|----------|----------|-------|--------|------------|------|\n';
            
            for (const issue of allIssues) {
              // Use backticks to format code-like elements and escape any pipe characters
              const safeTitle = issue.title.replace(/\|/g, '\\|');
              const safeImpact = issue.impact.replace(/\|/g, '\\|');
              const safeResolution = issue.resolution.replace(/\|/g, '\\|');
              
              table += `| ${issue.file} | \`${issue.resourcePath}\` | ${issue.severity} | ${safeTitle} | ${safeImpact} | ${safeResolution} | [Documentation](${issue.documentation}) |\n`;
            }
    
            body = `${marker}\n## üìÑ Snyk IaC Scan Results\n\nFound ${allIssues.length} infrastructure issue${allIssues.length > 1 ? 's' : ''}:\n\n${table}`;
          } else {
            console.log('üß™ Detected code scan format.');
            const vulns = results.vulnerabilities || [];
            if (vulns.length === 0) {
              if (existing) {
                await github.rest.issues.deleteComment({
                  comment_id: existing.id,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
              }
              return;
            }
            let table = '| Package | Version | Severity | Title | More Info |\n|---------|---------|----------|-------|------------|\n';
            for (const v of vulns) {
              const pkg = v.packageName || v.moduleName || 'unknown';
              const version = v.version || 'unknown';
              const severity = v.severity || 'unknown';
              const title = (v.title || 'unknown').replace(/\|/g, '-').slice(0, 80);
              let moreInfo = '';

              if (Array.isArray(v.references)) {
                const ref = v.references.find(r =>
                  typeof r.url === 'string' &&
                  (r.url.includes('huntr') || r.url.includes('blog') || r.title?.toLowerCase().includes('poc'))
                );
                if (ref) {
                  moreInfo = `[${ref.title || 'Link'}](${ref.url})`;
                }
              }
              
              table += `| ${pkg} | ${version} | ${severity} | ${title} | ${moreInfo} |\n`;
            }
            body = `${marker}\n## üîç Snyk Code Dependency Scan Results\n\n${table}`;
          }
    
          if (existing) {
            await github.rest.issues.updateComment({
              comment_id: existing.id,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body,
            });
          } else {
            await github.rest.issues.createComment({
              issue_number: number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body,
            });
          }
          
    - name: Generate PDF report from code scan
      if: ${{ inputs.generate-pdf-report == 'true' && inputs.scan-mode == 'code' }}
      run: |
        npm install -g snyk-to-html
        sudo apt-get update && sudo apt-get install -y wkhtmltopdf
        snyk-to-html -i ${{ inputs.json-output-file }} -o snyk-report.html
        wkhtmltopdf snyk-report.html snyk-report.pdf
      shell: bash

    - name: Upload PDF report as artifact
      if: ${{ inputs.generate-pdf-report == 'true' && inputs.scan-mode == 'code' }}
      uses: actions/upload-artifact@v4
      with:
        name: snyk-pdf-report
        path: snyk-report.pdf
        
    - name: Upload JSON as artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.scan-mode }}-${{ inputs.json-output-file }}
        path: snyk.json
